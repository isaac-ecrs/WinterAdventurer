@page "/"
@using MigraDoc.Rendering
@using PdfSharp.Fonts
@using PdfSharp.Pdf
@using WinterAdventurer.Library
@using System
@using System.IO
@using MudBlazor
@using WinterAdventurer.Library.Models
@using Microsoft.JSInterop
@using WinterAdventurer.Services
@using Microsoft.Extensions.Logging
@inject IJSRuntime JSRuntime
@inject ILocationService LocationService
@inject ILogger<Home> Logger
@rendermode InteractiveServer

<PageTitle>Home</PageTitle>

<h1>Winter Adventurer Workshop Manager</h1>

<MudFileUpload T="IBrowserFile" FilesChanged="UploadExcel" Accept=".xlsx">
    <ActivatorContent>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.CloudUpload">
            Upload Excel File
        </MudButton>
    </ActivatorContent>
</MudFileUpload>

@if (isLoading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
    <MudText>Processing...</MudText>
}

@if (!string.IsNullOrEmpty(errorMessage))
{
    <MudAlert Severity="Severity.Error" Class="mt-4">@errorMessage</MudAlert>
}

<!-- Timeslot Configuration Section - Always rendered but hidden until file uploaded -->
<div style="display: @(workshops.Count > 0 ? "block" : "none")">
    @if (hasOverlappingTimeslots)
    {
        <MudAlert Severity="Severity.Warning" Class="mt-4 mb-4">
            Warning: You have overlapping timeslots. Please adjust the times and click "Save Times" again.
        </MudAlert>
    }

    <MudPaper Class="pa-4 mb-4">
        <MudText Typo="Typo.h5" Class="mb-3">Configure Schedule Times</MudText>

        @foreach (var timeslot in timeslots)
        {
            <MudGrid Class="mb-2" @key="@timeslot.Id">
                <MudItem xs="4">
                    <MudTextField @bind-Value="timeslot.Label" Label="Period/Activity Name" Disabled="@timeslot.IsPeriod" />
                </MudItem>
                <MudItem xs="3">
                    <MudField Label="Start Time" Variant="Variant.Outlined">
                        <input type="time"
                               class="mud-input-slot mud-input-root mud-input-root-outlined"
                               style="padding: 10px; width: 100%;"
                               value="@FormatTimeSpan(timeslot.StartTime)"
                               @onchange="@(e => timeslot.StartTime = ParseTimeString(e.Value?.ToString()))" />
                    </MudField>
                </MudItem>
                <MudItem xs="3">
                    <MudField Label="End Time" Variant="Variant.Outlined">
                        <input type="time"
                               class="mud-input-slot mud-input-root mud-input-root-outlined"
                               style="padding: 10px; width: 100%;"
                               value="@FormatTimeSpan(timeslot.EndTime)"
                               @onchange="@(e => timeslot.EndTime = ParseTimeString(e.Value?.ToString()))" />
                    </MudField>
                </MudItem>
                <MudItem xs="2" Class="d-flex align-center">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                  Color="Color.Error"
                                  Disabled="@timeslot.IsPeriod"
                                  OnClick="() => RemoveTimeslot(timeslot)" />
                </MudItem>
            </MudGrid>
        }

        <MudButton StartIcon="@Icons.Material.Filled.Add" Color="Color.Primary" Variant="Variant.Text" OnClick="AddTimeslot">
            Add Non-Period Time Slot (e.g., Lunch, Break)
        </MudButton>
        <MudButton StartIcon="@Icons.Material.Filled.Save" Color="Color.Success" Variant="Variant.Filled" OnClick="SaveTimeslots" Class="ml-2">
            Save Times
        </MudButton>

        @if (timeslots.Count > 0)
        {
            <MudText Typo="Typo.caption" Class="mt-2">
                Note: Period timeslots (from Excel) cannot be deleted or renamed. Add additional timeslots for lunch, breaks, etc.
            </MudText>
        }
    </MudPaper>
</div>

@if (workshops != null && workshops.Count > 0)
{
    <MudText Typo="Typo.h5" Class="mb-3">Workshop Details</MudText>

    <EditForm Model=workshops OnValidSubmit="BuildPdf">
    <DataAnnotationsValidator />
    <MudGrid>
        <MudItem xs="12">
            <MudPaper Class="pa-4 mud-height-full">
                @if (!success)
                    {
                        <MudText Color="@Color.Error">
                            <ValidationSummary />
                        </MudText>
                    }
                </MudPaper>
            </MudItem>
        <MudItem xs="12" md="6">
            <MudTextField Label="Event Name" @bind-Value="eventName"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Event"
                          HelperText="Name for the master schedule (e.g., Winter Adventure 2025)" />
        </MudItem>
            @foreach (var workshop in workshops)
            {
                <MudItem xs="6">
                    <MudCard>
                        <MudCardHeader>
                            <CardHeaderContent>
                                <MudTextField Typo="Typo.h4" @bind-Value="workshop.Name" />
                            </CardHeaderContent>
                        </MudCardHeader>
                        <MudCardContent>
                            <MudText>@workshop.Selections.Count().ToString() Participants</MudText>
                            <MudText>@workshop.Period.DisplayName</MudText>
                            <div @onfocusout="@(() => OnLocationBlur(workshop))" @key="@($"loc-{workshop.Name}-{locationListVersion}")">
                                <MudAutocomplete T="string"
                                               Label="Location"
                                               @bind-Value="@workshop.Location"
                                               SearchFunc="@((value, token) => SearchLocations(value, token, workshop))"
                                               CoerceText="true"
                                               CoerceValue="true"
                                               ResetValueOnEmptyText="true"
                                               AdornmentIcon="@Icons.Material.Filled.LocationOn"
                                               AdornmentColor="Color.Primary"
                                               MinCharacters="0"
                                               DebounceInterval="300"
                                               ShowProgressIndicator="false"
                                               Dense="true"
                                               Variant="Variant.Outlined"
                                               SelectValueOnTab="true">
                                    <ItemTemplate Context="item">
                                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                                            <span>@item</span>
                                            <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                         Size="Size.Small"
                                                         Color="Color.Error"
                                                         OnClick="@(async (e) => await OnDeleteLocation(item, e))"
                                                         title="Delete this location" />
                                        </div>
                                    </ItemTemplate>
                                </MudAutocomplete>
                            </div>
                            <MudTextField Label="Leader" @bind-Value="workshop.Leader" />
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
            <MudItem xs="12" Class="d-flex gap-3">
                <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="Color.Primary">
                    Create PDF</MudButton>
                <MudButton ButtonType="ButtonType.Button" Variant="Variant.Filled" Color="Color.Secondary" OnClick="BuildMasterSchedulePdf">
                    Download Master Schedule</MudButton>
            </MudItem>
        </MudGrid>
    </EditForm>

}

@implements IDisposable

@code {
    private List<Workshop> workshops = new List<Library.Models.Workshop>();
    private bool isLoading;
    private ExcelUtilities context = new ExcelUtilities();
    private bool success = false;
    private string? errorMessage;
    private List<Period> periods = new List<Period>();
    private List<TimeSlot> timeslots = new List<TimeSlot>();
    private bool hasOverlappingTimeslots = false;
    private bool _disposed = false;
    private CancellationTokenSource? _cts;
    private bool _hasRendered = false;
    private List<string> availableLocations = new List<string>();
    private Dictionary<string, string> previousLocations = new Dictionary<string, string>();
    private int locationListVersion = 0; // Increment to force autocomplete recreation
    private string eventName = $"Winter Adventure {DateTime.Now.Year}";

    public class TimeSlot
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public string Label { get; set; } = string.Empty;
        public TimeSpan? StartTime { get; set; }
        public TimeSpan? EndTime { get; set; }
        public bool IsPeriod { get; set; } = false; // True if from Excel periods, false if user-added
    }

    protected override void OnInitialized()
    {
        _cts = new CancellationTokenSource();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_disposed)
        {
            _hasRendered = true;
            await LoadTimeslots();
            await LoadLocations();

            // Safe state change after async operation
            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task LoadTimeslots()
    {
        if (_disposed) return;

        try
        {
            Logger.LogInformation("LoadTimeslots: Loading timeslots from database");
            var dbTimeSlots = await LocationService.GetAllTimeSlotsAsync();

            if (dbTimeSlots != null && dbTimeSlots.Count > 0)
            {
                Logger.LogInformation("LoadTimeslots: Loaded {Count} timeslots from database", dbTimeSlots.Count);

                // Convert database TimeSlots to UI TimeSlots
                var loaded = dbTimeSlots.Select(t => new TimeSlot
                {
                    Id = t.Id,
                    Label = t.Label,
                    StartTime = t.StartTime,
                    EndTime = t.EndTime,
                    IsPeriod = t.IsPeriod
                }).ToList();

                // Clear and re-add instead of reassigning to avoid disposal issues
                timeslots.Clear();
                timeslots.AddRange(loaded);
                SortTimeslots();
                CheckForOverlaps();
                return;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading timeslots from database");
        }

        // Ensure list is empty if nothing loaded
        timeslots.Clear();
    }

    private async Task SaveTimeslots()
    {
        if (_disposed || !_hasRendered) return;

        try
        {
            // Sort and check overlaps before saving
            SortTimeslots();
            CheckForOverlaps();

            Logger.LogInformation("SaveTimeslots: Saving {Count} timeslots to database", timeslots.Count);

            // Convert UI TimeSlots to database TimeSlots
            var dbTimeSlots = timeslots.Select(t => new WinterAdventurer.Data.TimeSlot
            {
                Id = t.Id,
                Label = t.Label,
                StartTime = t.StartTime,
                EndTime = t.EndTime,
                IsPeriod = t.IsPeriod
            }).ToList();

            await LocationService.SaveAllTimeSlotsAsync(dbTimeSlots);
            Logger.LogInformation("SaveTimeslots: Successfully saved timeslots to database");

            // Safe state update after async operation
            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            if (!_disposed)
            {
                Logger.LogError(ex, "Error saving timeslots to database");
                errorMessage = $"Error saving timeslots: {ex.Message}";
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void SortTimeslots()
    {
        if (_disposed) return;

        // Sort in-place instead of reassigning to avoid disposal issues
        timeslots.Sort((a, b) =>
        {
            var aTime = a.StartTime ?? TimeSpan.MaxValue;
            var bTime = b.StartTime ?? TimeSpan.MaxValue;
            return aTime.CompareTo(bTime);
        });
    }

    private void CheckForOverlaps()
    {
        if (_disposed) return;

        hasOverlappingTimeslots = false;

        for (int i = 0; i < timeslots.Count - 1; i++)
        {
            var current = timeslots[i];
            var next = timeslots[i + 1];

            if (current.StartTime.HasValue && current.EndTime.HasValue &&
                next.StartTime.HasValue && next.EndTime.HasValue)
            {
                // Check if current end time is after next start time
                if (current.EndTime > next.StartTime)
                {
                    hasOverlappingTimeslots = true;
                    break;
                }
            }
        }
    }

    private async Task AddTimeslot()
    {
        if (_disposed) return;

        var newSlot = new TimeSlot { IsPeriod = false };
        timeslots.Add(newSlot);

        // Sort timeslots to maintain order
        SortTimeslots();

        if (!_disposed)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RemoveTimeslot(TimeSlot timeslot)
    {
        if (_disposed) return;

        if (!timeslot.IsPeriod)
        {
            timeslots.Remove(timeslot);

            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void PopulateTimeslotsFromPeriods()
    {
        if (_disposed) return;

        // Create a mapping of existing period labels to preserve IDs
        var existingPeriods = timeslots.Where(t => t.IsPeriod)
            .ToDictionary(t => t.Label, t => t);

        // Keep user-added timeslots
        var userSlots = timeslots.Where(t => !t.IsPeriod).ToList();

        // Clear all timeslots at once
        timeslots.Clear();

        // Re-add or create period timeslots, preserving IDs for existing ones
        foreach (var period in periods)
        {
            if (existingPeriods.TryGetValue(period.DisplayName, out var existingSlot))
            {
                // Reuse existing slot to preserve @key identity
                timeslots.Add(existingSlot);
            }
            else
            {
                // Create new slot for new periods
                timeslots.Add(new TimeSlot
                {
                    Label = period.DisplayName,
                    IsPeriod = true,
                    StartTime = null,
                    EndTime = null
                });
            }
        }

        // Re-add user slots
        timeslots.AddRange(userSlots);

        // Sort timeslots by start time
        SortTimeslots();
    }

    private async Task UploadExcel(IBrowserFile file)
    {
        if (_disposed) return;

        success = true;
        errorMessage = null;
        isLoading = true;
        workshops.Clear();

        try
        {
            using (var stream = new MemoryStream())
            {
                await file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024).CopyToAsync(stream);
                stream.Position = 0;
                context.ImportExcel(stream);
                workshops = context.Workshops;
                periods = workshops.Select(w => w.Period).Distinct().ToList();

                // Restore locations from saved mappings
                Logger.LogInformation("Restoring workshop locations from saved mappings");
                var mappings = await LocationService.GetAllWorkshopLocationMappingsAsync();
                Logger.LogInformation("Found {Count} saved workshop-location mappings", mappings.Count);

                foreach (var workshop in workshops)
                {
                    if (mappings.TryGetValue(workshop.Name, out var savedLocation))
                    {
                        workshop.Location = savedLocation;
                        Logger.LogDebug("Restored location '{Location}' for workshop '{Workshop}'",
                            savedLocation, workshop.Name);
                    }
                }

                // Initialize previous locations tracking
                previousLocations.Clear();
                foreach (var workshop in workshops)
                {
                    previousLocations[workshop.Name] = workshop.Location ?? string.Empty;
                }

                // Populate timeslots with periods from the Excel file
                PopulateTimeslotsFromPeriods();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error uploading file: {ex.Message}");
            errorMessage = $"Error uploading file: {ex.Message}";
            success = false;
        }

        isLoading = false;

        // Safe state update after async operation
        if (!_disposed)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task BuildPdf()
    {
        if (_disposed || !_hasRendered) return;

        try
        {
            errorMessage = null;
            isLoading = true;

            // Generate PDF document
            var document = context.CreatePdf(mergeWorkshopCells: true, timeslots: ConvertToLibraryTimeSlots());

            // Set up document styles (font resolver configured at startup)
            document.Styles["Normal"].Font.Name = "NotoSans";

            // Render the document
            var renderer = new PdfDocumentRenderer();
            renderer.Document = document;
            renderer.RenderDocument();

            // Save to memory stream
            using (var stream = new MemoryStream())
            {
                renderer.PdfDocument.Save(stream, false);
                stream.Position = 0;

                // Convert to byte array for download
                var bytes = stream.ToArray();
                var base64 = Convert.ToBase64String(bytes);

                // Trigger download in browser
                await JSRuntime.InvokeVoidAsync("downloadFile", _cts?.Token ?? default, "ClassRosters.pdf", base64);
            }

            isLoading = false;

            // Safe state update after async operation
            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            if (!_disposed)
            {
                Console.WriteLine($"Error generating PDF: {ex.Message}");
                errorMessage = $"Error generating PDF: {ex.Message}";
                success = false;
                isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task BuildMasterSchedulePdf()
    {
        if (_disposed || !_hasRendered) return;

        try
        {
            errorMessage = null;
            isLoading = true;

            // Generate master schedule PDF document
            var document = context.CreateMasterSchedulePdf(eventName: eventName, timeslots: ConvertToLibraryTimeSlots());

            // Set up document styles (font resolver configured at startup)
            document.Styles["Normal"].Font.Name = "NotoSans";

            // Render the document
            var renderer = new PdfDocumentRenderer();
            renderer.Document = document;
            renderer.RenderDocument();

            // Save to memory stream
            using (var stream = new MemoryStream())
            {
                renderer.PdfDocument.Save(stream, false);
                stream.Position = 0;

                // Convert to byte array for download
                var bytes = stream.ToArray();
                var base64 = Convert.ToBase64String(bytes);

                // Trigger download in browser
                await JSRuntime.InvokeVoidAsync("downloadFile", _cts?.Token ?? default, "MasterSchedule.pdf", base64);
            }

            isLoading = false;

            // Safe state update after async operation
            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            if (!_disposed)
            {
                Console.WriteLine($"Error generating master schedule PDF: {ex.Message}");
                errorMessage = $"Error generating master schedule PDF: {ex.Message}";
                success = false;
                isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    // Helper methods for native HTML5 time input conversion
    private string FormatTimeSpan(TimeSpan? time)
    {
        return time?.ToString(@"hh\:mm") ?? "";
    }

    private TimeSpan? ParseTimeString(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return null;

        if (TimeSpan.TryParse(value, out var result))
            return result;

        return null;
    }

    private List<WinterAdventurer.Library.Models.TimeSlot> ConvertToLibraryTimeSlots()
    {
        return timeslots.Select(t => new WinterAdventurer.Library.Models.TimeSlot
        {
            Id = t.Id,
            Label = t.Label,
            StartTime = t.StartTime,
            EndTime = t.EndTime,
            IsPeriod = t.IsPeriod
        }).ToList();
    }

    private async Task LoadLocations()
    {
        if (_disposed) return;

        try
        {
            Logger.LogInformation("LoadLocations: Starting to load locations from database");
            // Load all locations from database
            availableLocations = await LocationService.GetAllLocationNamesAsync();
            Logger.LogInformation("LoadLocations: Loaded {Count} locations", availableLocations.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading locations from database");
        }
    }

    private async Task<IEnumerable<string>> SearchLocations(string value, CancellationToken token, Workshop currentWorkshop)
    {
        Logger.LogDebug("SearchLocations called for workshop '{Workshop}' in period '{Period}' with value: '{Value}'",
            currentWorkshop.Name, currentWorkshop.Period.DisplayName, value ?? "NULL");

        // Get locations already used by OTHER workshops in the SAME period
        var usedLocations = workshops
            .Where(w => w.Period.SheetName == currentWorkshop.Period.SheetName &&
                       w.Name != currentWorkshop.Name &&
                       !string.IsNullOrWhiteSpace(w.Location))
            .Select(w => w.Location)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        Logger.LogDebug("SearchLocations: {Count} locations already used in period '{Period}': {Locations}",
            usedLocations.Count, currentWorkshop.Period.DisplayName, string.Join(", ", usedLocations));

        // Filter out used locations
        var available = availableLocations
            .Where(loc => !usedLocations.Contains(loc))
            .ToList();

        // If value is empty or null, return all available locations
        if (string.IsNullOrWhiteSpace(value))
        {
            Logger.LogDebug("SearchLocations: Returning {Count} available locations (empty search)", available.Count);
            return available;
        }

        // Filter locations that contain the search value (case insensitive)
        var filtered = available
            .Where(loc => loc.Contains(value, StringComparison.OrdinalIgnoreCase))
            .ToList();

        Logger.LogDebug("SearchLocations: Found {Count} matches for '{Value}'", filtered.Count, value);
        return await Task.FromResult(filtered);
    }

    private async Task OnLocationBlur(Workshop workshop)
    {
        var currentLocation = workshop.Location ?? string.Empty;
        var previousLocation = previousLocations.TryGetValue(workshop.Name, out var prev) ? prev : string.Empty;

        Logger.LogInformation("=== OnLocationBlur === Workshop: '{WorkshopName}', Current: '{Current}', Previous: '{Previous}'",
            workshop.Name, currentLocation, previousLocation);

        if (_disposed) return;

        // Only save if location actually changed
        if (currentLocation == previousLocation)
        {
            Logger.LogDebug("OnLocationBlur: No change, skipping save");
            return;
        }

        // Update tracking
        previousLocations[workshop.Name] = currentLocation;

        // Save to database if not empty
        if (!string.IsNullOrWhiteSpace(currentLocation))
        {
            try
            {
                Logger.LogInformation("OnLocationBlur: Saving location '{Location}' for workshop '{Workshop}'",
                    currentLocation, workshop.Name);
                await LocationService.AddOrGetLocationAsync(currentLocation);

                // Save the workshop-to-location mapping
                await LocationService.SaveWorkshopLocationMappingAsync(workshop.Name, currentLocation);

                // Update cached list if new
                if (!availableLocations.Contains(currentLocation))
                {
                    availableLocations.Add(currentLocation);
                    availableLocations.Sort();
                    Logger.LogInformation("OnLocationBlur: Added '{Location}' to cached list", currentLocation);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "OnLocationBlur: ERROR saving location '{Location}'", currentLocation);
            }
        }

        // Always increment version to refresh all dropdowns (for period-based filtering)
        locationListVersion++;
        Logger.LogDebug("OnLocationBlur: Incremented locationListVersion to {Version} to refresh all dropdowns", locationListVersion);
    }

    private async Task OnDeleteLocation(string locationName, MouseEventArgs e)
    {
        Logger.LogInformation("=== OnDeleteLocation === Location: '{Location}'", locationName);

        if (_disposed) return;

        try
        {
            var deleted = await LocationService.DeleteLocationAsync(locationName);
            if (deleted)
            {
                // Create a new list instance to trigger change detection in MudAutocomplete
                availableLocations = availableLocations.Where(l => l != locationName).ToList();
                Logger.LogInformation("OnDeleteLocation: Removed '{Location}' from cached list", locationName);

                // Clear any workshops that were using this location
                foreach (var workshop in workshops)
                {
                    if (workshop.Location == locationName)
                    {
                        workshop.Location = string.Empty;
                        previousLocations[workshop.Name] = string.Empty;
                        Logger.LogInformation("OnDeleteLocation: Cleared location from workshop '{Workshop}'", workshop.Name);
                    }
                }

                // Increment version to force autocomplete recreation (closes open dropdowns)
                locationListVersion++;
                Logger.LogDebug("OnDeleteLocation: Incremented locationListVersion to {Version}", locationListVersion);

                // Refresh UI
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "OnDeleteLocation: ERROR deleting location '{Location}'", locationName);
        }
    }

    public void Dispose()
    {
        _disposed = true;
        _cts?.Cancel();
        _cts?.Dispose();
    }
}

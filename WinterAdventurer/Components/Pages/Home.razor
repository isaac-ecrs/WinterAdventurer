@page "/"
@using MigraDoc.Rendering
@using PdfSharp.Fonts
@using PdfSharp.Pdf
@using WinterAdventurer.Library
@using System
@using System.IO
@using MudBlazor
@using WinterAdventurer.Library.Models
@using Microsoft.JSInterop
@using WinterAdventurer.Library.Services
@using WinterAdventurer.Services
@using WinterAdventurer.Components.Shared
@using Microsoft.Extensions.Logging
@using WinterAdventurer.Models
@using WinterAdventurer.Data
@inject IJSRuntime JSRuntime
@inject ILocationService LocationService
@inject ILogger<Home> Logger
@inject ExcelUtilities ExcelUtils
@inject ITimeslotValidationService TimeslotValidator
@inject TourService TourService
@rendermode InteractiveServer

<PageTitle>Home</PageTitle>

<FloatingActionButtons ShowReloadButton="@(workshops.Count > 0)" />

@if (workshops.Count == 0)
{
    <!-- Centered upload section when no file is uploaded -->
    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 80vh; text-align: center;">
        <MudText Typo="Typo.h4" Class="mb-4">Upload your Excel file to get started</MudText>
        <div id="file-upload-section">
            <FileUploadSection OnFileUploaded="UploadExcel" IsLoading="isLoading" />
        </div>
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mt-4">@errorMessage</MudAlert>
        }
    </div>
}

<!-- Error messages after file upload -->
@if (workshops.Count > 0 && !string.IsNullOrEmpty(errorMessage))
{
    <MudAlert Severity="Severity.Error" Class="mb-4">@errorMessage</MudAlert>
}

<!-- Timeslot Configuration Section - Always rendered but hidden until file uploaded -->
<div id="timeslot-editor" style="display: @(workshops.Count > 0 ? "block" : "none")">
    @if (hasUnconfiguredTimeslots)
    {
        <MudAlert Severity="Severity.Error" Class="mt-4 mb-4">
            <strong>PDF generation is blocked:</strong> Some period timeslots are missing start or end times. Please configure all period times and click "Save Times".
        </MudAlert>
    }
    else if (hasOverlappingTimeslots)
    {
        <MudAlert Severity="Severity.Error" Class="mt-4 mb-4">
            <strong>PDF generation is blocked:</strong> You have overlapping or duplicate timeslots (same start times). Please adjust the times and click "Save Times" again.
        </MudAlert>
    }

    <TimeslotEditor Timeslots="timeslots"
                    OnTimeslotsChanged="OnTimeslotsChanged"
                    OnSaveTimeslots="SaveTimeslots" />
</div>

@if (workshops != null && workshops.Count > 0)
{
    <div id="workshop-grid">
        <MudText Typo="Typo.h5" Class="mb-3">Workshop Details</MudText>

        <WorkshopGrid Workshops="workshops"
                  EventName="@eventName"
                  EventNameChanged="EventCallback.Factory.Create<string>(this, value => eventName = value)"
                  DefaultEventName="@defaultEventName"
                  BlankScheduleCount="@blankScheduleCount"
                  BlankScheduleCountChanged="EventCallback.Factory.Create<int>(this, OnBlankScheduleCountChanged)"
                  Success="@success"
                  IsDisabled="@(hasOverlappingTimeslots || hasUnconfiguredTimeslots)"
                  AvailableLocations="@availableLocations"
                  LocationListVersion="@locationListVersion"
                  OnValidSubmit="BuildPdf"
                  OnCreateMasterSchedule="BuildMasterSchedulePdf"
                  OnWorkshopLocationChanged="HandleWorkshopLocationChanged"
                  OnDeleteLocationRequested="HandleDeleteLocationRequest" />
    </div>
}

@implements IDisposable

@code {
    private List<Workshop> workshops = new List<Library.Models.Workshop>();
    private bool isLoading;
    private bool success = false;
    private string? errorMessage;
    private List<Period> periods = new List<Period>();
    private List<TimeSlotViewModel> timeslots = new List<TimeSlotViewModel>();
    private bool hasOverlappingTimeslots = false;
    private bool hasUnconfiguredTimeslots = false;
    private bool _disposed = false;
    private CancellationTokenSource? _cts;
    private bool _hasRendered = false;
    private List<Location> availableLocations = new List<Location>();
    private int locationListVersion = 0; // Increment to force autocomplete recreation
    private string eventName = "";
    private string defaultEventName = $"Winter Adventure {DateTime.Now.Year}";
    private int blankScheduleCount = 0;

    private void OnBlankScheduleCountChanged(int newValue)
    {
        Logger.LogInformation($"Blank schedule count changed: {blankScheduleCount} -> {newValue}");
        blankScheduleCount = newValue;
    }

    protected override void OnInitialized()
    {
        _cts = new CancellationTokenSource();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_disposed)
        {
            _hasRendered = true;
            await LoadTimeslots();
            await LoadLocations();

            // Check if user needs the guided tour
            var tourCompleted = await TourService.HasCompletedTourAsync("home");
            Console.WriteLine($"Home.OnAfterRenderAsync: Tour completed = {tourCompleted}");
            if (!tourCompleted)
            {
                Console.WriteLine("Home.OnAfterRenderAsync: Starting tour...");
                // Brief delay to allow UI to fully render before starting tour
                await Task.Delay(500);
                await TourService.StartHomeTourAsync();
            }
            else
            {
                Console.WriteLine("Home.OnAfterRenderAsync: Tour already completed, skipping");
            }

            // Safe state change after async operation
            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task LoadTimeslots()
    {
        if (_disposed) return;

        try
        {
            Logger.LogInformation("LoadTimeslots: Loading timeslots from database");
            var dbTimeSlots = await LocationService.GetAllTimeSlotsAsync();

            if (dbTimeSlots != null && dbTimeSlots.Count > 0)
            {
                Logger.LogInformation("LoadTimeslots: Loaded {Count} timeslots from database", dbTimeSlots.Count);

                // Convert database TimeSlots to UI TimeSlots
                var loaded = dbTimeSlots.Select(t => new TimeSlotViewModel
                {
                    Id = t.Id,
                    Label = t.Label,
                    StartTime = t.StartTime,
                    EndTime = t.EndTime,
                    IsPeriod = t.IsPeriod
                }).ToList();

                // Clear and re-add instead of reassigning to avoid disposal issues
                timeslots.Clear();
                timeslots.AddRange(loaded);
                SortTimeslots();
                ValidateTimeslots();
                return;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading timeslots from database");
        }

        // Ensure list is empty if nothing loaded
        timeslots.Clear();
    }

    private async Task SaveTimeslots()
    {
        if (_disposed || !_hasRendered) return;

        try
        {
            // Sort and validate timeslots before saving
            SortTimeslots();
            ValidateTimeslots();

            Logger.LogInformation("SaveTimeslots: Saving {Count} timeslots to database", timeslots.Count);

            // Convert UI TimeSlots to database TimeSlots
            var dbTimeSlots = timeslots.Select(t => new WinterAdventurer.Data.TimeSlot
            {
                Id = t.Id,
                Label = t.Label,
                StartTime = t.StartTime,
                EndTime = t.EndTime,
                IsPeriod = t.IsPeriod
            }).ToList();

            await LocationService.SaveAllTimeSlotsAsync(dbTimeSlots);
            Logger.LogInformation("SaveTimeslots: Successfully saved timeslots to database");

            // Safe state update after async operation
            if (!_disposed)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            if (!_disposed)
            {
                Logger.LogError(ex, "Error saving timeslots to database");
                errorMessage = $"Error saving timeslots: {ex.Message}";
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void SortTimeslots()
    {
        if (_disposed) return;

        // Sort in-place instead of reassigning to avoid disposal issues
        timeslots.Sort((a, b) =>
        {
            var aTime = a.StartTime ?? TimeSpan.MaxValue;
            var bTime = b.StartTime ?? TimeSpan.MaxValue;
            return aTime.CompareTo(bTime);
        });
    }

    private void ValidateTimeslots()
    {
        if (_disposed) return;

        var timeslotDtos = timeslots.Select(t => new TimeSlotDto
        {
            Id = t.Id,
            Label = t.Label,
            StartTime = t.StartTime,
            EndTime = t.EndTime,
            IsPeriod = t.IsPeriod
        });

        var validationResult = TimeslotValidator.ValidateTimeslots(timeslotDtos);
        hasOverlappingTimeslots = validationResult.HasOverlappingTimeslots;
        hasUnconfiguredTimeslots = validationResult.HasUnconfiguredTimeslots;
    }

    private async Task OnTimeslotsChanged()
    {
        if (_disposed) return;

        // Sort and validate timeslots whenever they change
        SortTimeslots();
        ValidateTimeslots();

        if (!_disposed)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void PopulateTimeslotsFromPeriods()
    {
        if (_disposed) return;

        // Create a mapping of existing period labels to preserve IDs
        var existingPeriods = timeslots.Where(t => t.IsPeriod)
            .ToDictionary(t => t.Label, t => t);

        // Keep user-added timeslots
        var userSlots = timeslots.Where(t => !t.IsPeriod).ToList();

        // Clear all timeslots at once
        timeslots.Clear();

        // Re-add or create period timeslots, preserving IDs for existing ones
        foreach (var period in periods)
        {
            if (existingPeriods.TryGetValue(period.DisplayName, out var existingSlot))
            {
                // Reuse existing slot to preserve @key identity
                timeslots.Add(existingSlot);
            }
            else
            {
                // Create new slot for new periods
                timeslots.Add(new TimeSlotViewModel
                {
                    Label = period.DisplayName,
                    IsPeriod = true,
                    StartTime = null,
                    EndTime = null
                });
            }
        }

        // Re-add user slots
        timeslots.AddRange(userSlots);

        // Sort timeslots by start time and validate
        SortTimeslots();
        ValidateTimeslots();
    }

    private async Task UploadExcel(IBrowserFile file)
    {
        if (_disposed) return;

        success = true;
        errorMessage = null;
        isLoading = true;
        workshops.Clear();
        ExcelUtils.Workshops.Clear(); // Clear previous workshops from ExcelUtils

        // Clear any previous tour errors
        try
        {
            await JSRuntime.InvokeVoidAsync("clearTourError");
        }
        catch (Exception jsEx)
        {
            Logger.LogWarning(jsEx, "Failed to clear tour error (JS interop)");
        }

        try
        {
            using (var stream = new MemoryStream())
            {
                await file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024).CopyToAsync(stream);
                stream.Position = 0;
                ExcelUtils.ImportExcel(stream);
                workshops = ExcelUtils.Workshops;
                periods = workshops.Select(w => w.Period).Distinct().ToList();

                // Restore locations from saved mappings
                Logger.LogInformation("Restoring workshop locations from saved mappings");
                var mappings = await LocationService.GetAllWorkshopLocationMappingsAsync();
                Logger.LogInformation("Found {Count} saved workshop-location mappings", mappings.Count);

                foreach (var workshop in workshops)
                {
                    if (mappings.TryGetValue(workshop.Name, out var savedLocation))
                    {
                        workshop.Location = savedLocation;
                        Logger.LogDebug("Restored location '{Location}' for workshop '{Workshop}'",
                            savedLocation, workshop.Name);
                    }
                }

                // Populate timeslots with periods from the Excel file
                PopulateTimeslotsFromPeriods();

                // Notify the tour that file upload is complete
                try
                {
                    await JSRuntime.InvokeVoidAsync("notifyTourFileUploaded");
                }
                catch (Exception jsEx)
                {
                    Logger.LogWarning(jsEx, "Failed to notify tour of file upload (JS interop)");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error uploading file: {ex.Message}");
            errorMessage = $"Error uploading file: {ex.Message}";
            success = false;

            // Show error in tour if active
            try
            {
                await JSRuntime.InvokeVoidAsync("showTourError", errorMessage);
            }
            catch (Exception jsEx)
            {
                Logger.LogWarning(jsEx, "Failed to show tour error (JS interop)");
            }
        }

        isLoading = false;

        // Safe state update after async operation
        if (!_disposed)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task BuildPdf()
    {
        Logger.LogInformation("========== BuildPdf method called ==========");
        Logger.LogInformation($"BuildPdf: blankScheduleCount = {blankScheduleCount}");
        Logger.LogInformation($"BuildPdf: _disposed = {_disposed}, _hasRendered = {_hasRendered}");

        if (_disposed || !_hasRendered)
        {
            Logger.LogWarning("BuildPdf: Exiting early - disposed or not rendered yet");
            return;
        }

        try
        {
            Logger.LogInformation("BuildPdf: Starting PDF generation");
            errorMessage = null;
            isLoading = true;
            await InvokeAsync(StateHasChanged); // Immediate UI update

            // Capture variables before Task.Run to ensure proper closure
            var localBlankScheduleCount = blankScheduleCount;
            var localTimeslots = ConvertToLibraryTimeSlots();

            Logger.LogInformation($"BuildPdf: Captured localBlankScheduleCount = {localBlankScheduleCount}");
            Logger.LogInformation($"BuildPdf: Captured {localTimeslots?.Count ?? 0} timeslots");

            // Load locations with tags for PDF generation
            var locationsWithTags = await LocationService.GetAllLocationsWithTagsAsync();

            // Map to dictionary for quick lookup
            var locationTagsDict = locationsWithTags
                .Where(l => l.Tags.Any())
                .ToDictionary(
                    l => l.Name,
                    l => l.Tags.Select(t => new WinterAdventurer.Library.Models.LocationTag
                    {
                        Name = t.Name
                    }).ToList()
                );

            // Generate PDF in background thread to keep SignalR circuit alive
            var (pdfBytes, error) = await Task.Run(() =>
            {
                try
                {
                    Logger.LogInformation($"Task.Run: Calling CreatePdf with blankScheduleCount={localBlankScheduleCount}");
                    var finalEventName = string.IsNullOrWhiteSpace(eventName) ? defaultEventName : eventName;

                    // Populate workshop tags from location data
                    foreach (var workshop in ExcelUtils.Workshops)
                    {
                        if (locationTagsDict.TryGetValue(workshop.Location, out var tags))
                        {
                            workshop.Tags = tags;
                        }
                    }

                    var document = ExcelUtils.CreatePdf(mergeWorkshopCells: true, timeslots: localTimeslots, blankScheduleCount: localBlankScheduleCount, eventName: finalEventName);
                    if (document == null)
                    {
                        Logger.LogWarning("Task.Run: CreatePdf returned null document");
                        return (Array.Empty<byte>(), "No document generated (no workshops found)");
                    }

                    Logger.LogInformation($"Task.Run: Document created with {document.Sections.Count} sections");
                    document!.Styles["Normal"]!.Font.Name = "NotoSans";

                    var renderer = new PdfDocumentRenderer();
                    renderer.Document = document;
                    Logger.LogInformation("Task.Run: Rendering PDF document");
                    renderer.RenderDocument();

                    using (var stream = new MemoryStream())
                    {
                        renderer.PdfDocument.Save(stream, false);
                        Logger.LogInformation($"Task.Run: PDF saved, size={stream.Length} bytes");
                        return (stream.ToArray(), (string?)null);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, $"Task.Run: Exception during PDF generation: {ex.Message}");
                    return (Array.Empty<byte>(), ex.Message);
                }
            });

            if (!string.IsNullOrEmpty(error))
            {
                Logger.LogError($"BuildPdf: PDF generation failed: {error}");
                errorMessage = $"Error generating PDF: {error}";
                success = false;
            }
            else
            {
                Logger.LogInformation($"BuildPdf: PDF generated successfully, downloading to browser");
                var base64 = Convert.ToBase64String(pdfBytes);
                await JSRuntime.InvokeVoidAsync("downloadFile", _cts?.Token ?? default, "ClassRosters.pdf", base64);
                Logger.LogInformation("BuildPdf: PDF download initiated");
            }

            isLoading = false;
            if (!_disposed) await InvokeAsync(StateHasChanged);
            Logger.LogInformation("========== BuildPdf method completed ==========");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"BuildPdf: Outer exception caught: {ex.Message}");
            if (!_disposed)
            {
                Console.WriteLine($"Error generating PDF: {ex.Message}");
                errorMessage = $"Error generating PDF: {ex.Message}";
                success = false;
                isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task BuildMasterSchedulePdf()
    {
        if (_disposed || !_hasRendered) return;

        try
        {
            errorMessage = null;
            isLoading = true;
            await InvokeAsync(StateHasChanged); // Immediate UI update

            // Generate PDF in background thread to keep SignalR circuit alive
            var (pdfBytes, error) = await Task.Run(() =>
            {
                try
                {
                    var finalEventName = string.IsNullOrWhiteSpace(eventName) ? defaultEventName : eventName;
                    var document = ExcelUtils.CreateMasterSchedulePdf(eventName: finalEventName, timeslots: ConvertToLibraryTimeSlots());
                    if (document == null)
                    {
                        return (Array.Empty<byte>(), "No document generated (no workshops found)");
                    }

                    document!.Styles["Normal"]!.Font.Name = "NotoSans";

                    var renderer = new PdfDocumentRenderer();
                    renderer.Document = document;
                    renderer.RenderDocument();

                    using (var stream = new MemoryStream())
                    {
                        renderer.PdfDocument.Save(stream, false);
                        return (stream.ToArray(), (string?)null);
                    }
                }
                catch (Exception ex)
                {
                    return (Array.Empty<byte>(), ex.Message);
                }
            });

            if (!string.IsNullOrEmpty(error))
            {
                errorMessage = $"Error generating master schedule PDF: {error}";
                success = false;
            }
            else
            {
                var base64 = Convert.ToBase64String(pdfBytes);
                await JSRuntime.InvokeVoidAsync("downloadFile", _cts?.Token ?? default, "MasterSchedule.pdf", base64);
            }

            isLoading = false;
            if (!_disposed) await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            if (!_disposed)
            {
                errorMessage = $"Error generating master schedule PDF: {ex.Message}";
                success = false;
                isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private List<WinterAdventurer.Library.Models.TimeSlot> ConvertToLibraryTimeSlots()
    {
        return timeslots.Select(t => new WinterAdventurer.Library.Models.TimeSlot
        {
            Id = t.Id,
            Label = t.Label,
            StartTime = t.StartTime,
            EndTime = t.EndTime,
            IsPeriod = t.IsPeriod
        }).ToList();
    }

    private async Task LoadLocations()
    {
        if (_disposed) return;

        try
        {
            Logger.LogInformation("LoadLocations: Starting to load locations with tags from database");
            // Load all locations with tags from database
            availableLocations = await LocationService.GetAllLocationsWithTagsAsync();
            Logger.LogInformation("LoadLocations: Loaded {Count} locations with tags", availableLocations.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading locations from database");
        }
    }

    /// <summary>
    /// Event handler called when a workshop's location changes.
    /// Updates the available locations cache and increments version to refresh all cards.
    /// </summary>
    private async Task HandleWorkshopLocationChanged(Workshop workshop)
    {
        if (_disposed) return;

        var currentLocation = workshop.Location ?? string.Empty;

        // Update cached list if new location added
        if (!string.IsNullOrWhiteSpace(currentLocation) &&
            !availableLocations.Any(loc => loc.Name.Equals(currentLocation, StringComparison.OrdinalIgnoreCase)))
        {
            // Fetch the location from database (it should exist since AddOrGetLocationAsync was called)
            var locationEntity = await LocationService.GetLocationByNameAsync(currentLocation);
            if (locationEntity != null)
            {
                availableLocations.Add(locationEntity);
                availableLocations = availableLocations.OrderBy(loc => loc.Name).ToList();
                Logger.LogInformation("HandleWorkshopLocationChanged: Added '{Location}' to cached list", currentLocation);
            }
        }

        // Increment version to refresh all dropdowns (for period-based filtering)
        locationListVersion++;
        Logger.LogDebug("HandleWorkshopLocationChanged: Incremented locationListVersion to {Version}", locationListVersion);

        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Event handler called when user requests to delete a location.
    /// Deletes from database and clears from all affected workshops.
    /// </summary>
    private async Task HandleDeleteLocationRequest(string locationName)
    {
        Logger.LogInformation("=== HandleDeleteLocationRequest === Location: '{Location}'", locationName);

        if (_disposed) return;

        try
        {
            var deleted = await LocationService.DeleteLocationAsync(locationName);
            if (deleted)
            {
                // Create a new list instance to trigger change detection in MudAutocomplete
                availableLocations = availableLocations.Where(l => !l.Name.Equals(locationName, StringComparison.OrdinalIgnoreCase)).ToList();
                Logger.LogInformation("HandleDeleteLocationRequest: Removed '{Location}' from cached list", locationName);

                // Clear any workshops that were using this location
                foreach (var workshop in workshops)
                {
                    if (workshop.Location == locationName)
                    {
                        workshop.Location = string.Empty;
                        Logger.LogInformation("HandleDeleteLocationRequest: Cleared location from workshop '{Workshop}'", workshop.Name);
                    }
                }

                // Increment version to force autocomplete recreation (closes open dropdowns)
                locationListVersion++;
                Logger.LogDebug("HandleDeleteLocationRequest: Incremented locationListVersion to {Version}", locationListVersion);

                // Refresh UI
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "HandleDeleteLocationRequest: ERROR deleting location '{Location}'", locationName);
        }
    }

    public void Dispose()
    {
        _disposed = true;
        _cts?.Cancel();
        _cts?.Dispose();
    }
}

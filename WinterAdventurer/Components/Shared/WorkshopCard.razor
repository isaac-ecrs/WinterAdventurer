@using MudBlazor
@using WinterAdventurer.Library.Models
@using WinterAdventurer.Services
@using WinterAdventurer.Data
@using Microsoft.Extensions.Logging
@inject ILocationService LocationService
@inject ILogger<WorkshopCard> Logger
@inject AnimationSettingsService AnimationSettings

<div class="workshop-card-wrapper" style="animation-delay: @(CardIndex * 50)ms">
    <MudCard>
    <MudCardHeader>
        <CardHeaderContent>
            <MudTextField Typo="Typo.h4" @bind-Value="Workshop.Name" />
        </CardHeaderContent>
    </MudCardHeader>
    <MudCardContent>
        <MudText>@Workshop.Selections.Count().ToString() Participants</MudText>
        <MudText>@Workshop.Period.DisplayName</MudText>
        <div class="@(locationJustChanged ? "location-field-changed" : "")"
             @onfocusout="OnLocationBlur"
             @key="@($"loc-{Workshop.Name}-{LocationListVersion}")"
             id="@(CardIndex == 0 ? "first-workshop-location" : null)"
             data-card-index="@CardIndex"
             style="position: relative;">
            <MudAutocomplete T="Location"
                           Label="Location"
                           Value="@selectedLocation"
                           ValueChanged="@OnLocationSelected"
                           SearchFunc="@SearchLocations"
                           ToStringFunc="@(loc => loc?.Name ?? string.Empty)"
                           CoerceText="true"
                           CoerceValue="true"
                           ResetValueOnEmptyText="true"
                           AdornmentIcon="@Icons.Material.Filled.LocationOn"
                           AdornmentColor="Color.Primary"
                           MinCharacters="0"
                           DebounceInterval="300"
                           ShowProgressIndicator="false"
                           Dense="true"
                           Variant="Variant.Outlined"
                           SelectValueOnTab="true">
                <ItemTemplate Context="item">
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 8px;">
                        <div style="display: flex; align-items: center; gap: 4px; flex: 1;">
                            <span>@item.Name</span>
                            @foreach (var tag in item.Tags.OrderBy(t => t.Name))
                            {
                                <MudChip T="string"
                                         Size="Size.Small"
                                         Color="Color.Default"
                                         Style="@($"background-color: {tag.Color ?? "#e0e0e0"}; color: white; font-size: 0.7rem; height: 18px;")">
                                    @tag.Name
                                </MudChip>
                            }
                        </div>
                        <MudIconButton Icon="@Icons.Material.Filled.Close"
                                     Size="Size.Small"
                                     Color="Color.Error"
                                     OnClick="@((e) => OnDeleteLocationClick(item.Name, e))"
                                     title="Delete this location" />
                    </div>
                </ItemTemplate>
            </MudAutocomplete>
        </div>
        <div id="@(CardIndex == 0 ? "first-workshop-leader" : null)"
             data-card-index="@CardIndex"
             style="position: relative;">
            <MudTextField Label="Leader"
                          @bind-Value="Workshop.Leader" />
        </div>
    </MudCardContent>
    </MudCard>
</div>

@code {
    /// <summary>
    /// The workshop to display and edit
    /// </summary>
    [Parameter, EditorRequired]
    public Workshop Workshop { get; set; } = default!;

    /// <summary>
    /// All workshops in the current session, used for period-based location filtering
    /// </summary>
    [Parameter, EditorRequired]
    public List<Workshop> AllWorkshops { get; set; } = default!;

    /// <summary>
    /// Index of this card in the grid (0-based). Used to add IDs to the first card for tour guidance.
    /// </summary>
    [Parameter]
    public int CardIndex { get; set; } = -1;

    /// <summary>
    /// List of all available locations from the database (with tags loaded)
    /// </summary>
    [Parameter, EditorRequired]
    public List<Location> AvailableLocations { get; set; } = default!;

    /// <summary>
    /// Version number used to force component refresh when locations change globally.
    /// Increment this value to recreate the autocomplete component.
    /// </summary>
    [Parameter, EditorRequired]
    public int LocationListVersion { get; set; }

    /// <summary>
    /// Callback invoked when the workshop's location changes (on blur).
    /// Parent should increment LocationListVersion to refresh all cards.
    /// </summary>
    [Parameter]
    public EventCallback<Workshop> OnLocationChanged { get; set; }

    /// <summary>
    /// Callback invoked when user clicks delete button for a location.
    /// Parent should handle database deletion and update all affected workshops.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnDeleteLocationRequested { get; set; }

    private string previousLocation = string.Empty;
    private Location? selectedLocation = null;
    private bool locationJustChanged = false;

    protected override void OnParametersSet()
    {
        previousLocation = Workshop.Location ?? string.Empty;

        // Find the Location object that matches the current workshop location string
        selectedLocation = AvailableLocations?.FirstOrDefault(loc =>
            loc.Name.Equals(Workshop.Location, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Handles location selection from autocomplete.
    /// Updates Workshop.Location string property.
    /// </summary>
    private void OnLocationSelected(Location? location)
    {
        selectedLocation = location;
        Workshop.Location = location?.Name ?? string.Empty;
    }

    /// <summary>
    /// Search function for location autocomplete with period-based filtering.
    /// Filters out locations already used by other workshops in the same period.
    /// </summary>
    private async Task<IEnumerable<Location>> SearchLocations(string value, CancellationToken token)
    {
        Logger.LogDebug("SearchLocations called for workshop '{Workshop}' in period '{Period}' with value: '{Value}'",
            Workshop.Name, Workshop.Period.DisplayName, value ?? "NULL");

        // Get locations already used by OTHER workshops in the SAME period
        var usedLocations = AllWorkshops
            .Where(w => w.Period.SheetName == Workshop.Period.SheetName &&
                       w.Name != Workshop.Name &&
                       !string.IsNullOrWhiteSpace(w.Location))
            .Select(w => w.Location)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        Logger.LogDebug("SearchLocations: {Count} locations already used in period '{Period}': {Locations}",
            usedLocations.Count, Workshop.Period.DisplayName, string.Join(", ", usedLocations));

        // Filter out used locations
        var available = AvailableLocations
            .Where(loc => !usedLocations.Contains(loc.Name))
            .ToList();

        // If value is empty or null, return all available locations
        if (string.IsNullOrWhiteSpace(value))
        {
            Logger.LogDebug("SearchLocations: Returning {Count} available locations (empty search)", available.Count);
            return available;
        }

        // Filter locations that contain the search value (case insensitive)
        var filtered = available
            .Where(loc => loc.Name.Contains(value, StringComparison.OrdinalIgnoreCase))
            .ToList();

        Logger.LogDebug("SearchLocations: Found {Count} matches for '{Value}'", filtered.Count, value);
        return await Task.FromResult(filtered);
    }

    /// <summary>
    /// Handles focus out event on location autocomplete.
    /// Saves location to database and invokes parent callback if value changed.
    /// </summary>
    private async Task OnLocationBlur()
    {
        var currentLocation = Workshop.Location ?? string.Empty;

        Logger.LogInformation("=== OnLocationBlur === Workshop: '{WorkshopName}', Current: '{Current}', Previous: '{Previous}'",
            Workshop.Name, currentLocation, previousLocation);

        // Only save if location actually changed
        if (currentLocation == previousLocation)
        {
            Logger.LogDebug("OnLocationBlur: No change, skipping save");
            return;
        }

        // Update tracking
        previousLocation = currentLocation;

        // Save to database if not empty
        if (!string.IsNullOrWhiteSpace(currentLocation))
        {
            try
            {
                Logger.LogInformation("OnLocationBlur: Saving location '{Location}' for workshop '{Workshop}'",
                    currentLocation, Workshop.Name);
                await LocationService.AddOrGetLocationAsync(currentLocation);

                // Save the workshop-to-location mapping
                await LocationService.SaveWorkshopLocationMappingAsync(Workshop.Name, currentLocation);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "OnLocationBlur: ERROR saving location '{Location}'", currentLocation);
            }
        }

        // Notify parent that location changed (parent will increment version and add to cache)
        await OnLocationChanged.InvokeAsync(Workshop);

        // Show pulse animation (600ms animation adjusted by intensity)
        locationJustChanged = true;
        StateHasChanged();
        await Task.Delay(AnimationSettings.GetAdjustedDelay(600));
        locationJustChanged = false;
        StateHasChanged();
    }

    /// <summary>
    /// Handles click event on delete button in location dropdown.
    /// Invokes parent callback to handle database deletion.
    /// </summary>
    private async Task OnDeleteLocationClick(string locationName, MouseEventArgs e)
    {
        Logger.LogInformation("=== OnDeleteLocationClick === Location: '{Location}'", locationName);
        await OnDeleteLocationRequested.InvokeAsync(locationName);
    }
}
